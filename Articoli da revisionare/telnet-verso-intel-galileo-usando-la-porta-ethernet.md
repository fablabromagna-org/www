---
title: 'Telnet verso Intel Galileo usando la porta Ethernet'
date: Fri, 18 Apr 2014 04:39:00 +0000
draft: false
tags: ['Intel Galileo']
---

Intel Galileo rispetto ad Arduino, ha dotazioni hardware più evolute quindi anche il firmware che ha a bordo è inevitabilmente più ricco. Questo firmware è basato su una piccola distribuzione linux ritagliata sull’hardware di Galileo e residente nella sua flash. E’ possibile accedere ad una shell di questa distribuzione, usando un normale telnet a patto che

*   il daemon telnetd su Galileo sia operativo
*   si conosca l’IP di Galileo

Sfortunatamente, all’accensione di Galileo, la ETH0 non è configurata e il daemon telnetd è spento. Il problema è che solo via shelli si può rimediare ad entrambe le cose!! La soluzione è nel runtime di Galileo (che risiede naturalmente nel firmware di Galileo) Cos’è il runtime di Galileo? Il runtime di Galileo è un insieme di utility a corredo di questa distribuzione linux. Una cassettina degli attrezzi creata apposta per ospitare il mondo Arduino dentro al linux di Galileo. Ad esempio il piccolo processo che gira lato Galileo e che accetta comandi dall’IDE fa parte del runtime. Questo processo, parte al reset della scheda e fa almeno due cose:

*   rimane in attesa che qualcuno (di solito l’IDE) spedisca qualcosa da fare (cancellare il programma utente attuale, scaricare il nuovo, mandarlo in esecuzione…)
*   se non c’è nulla da fare comunque, manda in esecuzione l’ultimo programma eseguibile dell’utente (il programma risultato dalla compilazione del file .ino) Attenzione. Galileo (con il firmware che sulla scheda madre) all’avvio, non si comporta come Arduino il quale esegue l’ultimo programma utente scaricatogli. Galileo, al boot, infatti “dimentica” l’ultimo programma che gli abbiamo scaricato dentro, rendendolo ogni volta vergine.

Esempio di log di una sessione di comandi inviati dall’IDE di Arduino Galileo alla scheda Galileo[![image](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image_thumb1.png "image")](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image1.png) Un’altra caratteristica del runtime di Galileo è quella di consentire ad un programma utente di lanciare comandi della shell di linux che sta alla base di Galileo. Per farlo si utilizza il metodo di libreria system() (che sta in stdlib.h) all’interno di un file .ino, in questo modo: void setup() {  // Avvia il daemon del telnet sul Galileo system("telnetd -l /bin/sh"); // configura la Ethernet su un address temporaneo. // Questo causa la richiesta di un IP dal DHCP… system("ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up"); } void loop() { // Invia alla seriale l’IP assegnato dal DHCP system("ifconfig eth0 | grep 'inet addr:' | cut -d: -f2 | awk '{ print $1}' > /dev/ttyGS0"); sleep(10); } A questo punto sul serial monitor, appare continuamente l’IP del Galileo. [![MonitorSeriale](http://fablabromagna.org/blog/wp-content/uploads/2014/04/MonitorSeriale_thumb.png "MonitorSeriale")](http://fablabromagna.org/blog/wp-content/uploads/2014/04/MonitorSeriale.png) Una volta scoperto l’IP si fa Telnet nei consueti modi. [![TelnetSuGalileo](http://fablabromagna.org/blog/wp-content/uploads/2014/04/TelnetSuGalileo_thumb.png "TelnetSuGalileo")](http://fablabromagna.org/blog/wp-content/uploads/2014/04/TelnetSuGalileo.png) E qui comincia il bello… Ad esempio… si può usare l’IOCTL classico di linux per accedere alla GPIO di Galileo… [![image](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image_thumb2.png "image")](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image2.png) E il led si accende!! [![image](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image_thumb3.png "image")](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image3.png) Mentre con … [![image](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image_thumb4.png "image")](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image4.png) ... il led si spegne! [![image](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image_thumb5.png "image")](http://fablabromagna.org/blog/wp-content/uploads/2014/04/image5.png) Qui c’è la mappa dei pin di I/O [https://communities.intel.com/servlet/JiveServlet/previewBody/21920-102-2-25976/GalileoIOMappingRev2.pdf](https://communities.intel.com/servlet/JiveServlet/previewBody/21920-102-2-25976/GalileoIOMappingRev2.pdf "https://communities.intel.com/servlet/JiveServlet/previewBody/21920-102-2-25976/GalileoIOMappingRev2.pdf") E qui un riassunto molto bello di come si configurano le DIR dei vari pin e dei mux interni [http://www.malinov.com/Home/sergey-s-blog/intelgalileo-programminggpiofromlinux](http://www.malinov.com/Home/sergey-s-blog/intelgalileo-programminggpiofromlinux "http://www.malinov.com/Home/sergey-s-blog/intelgalileo-programminggpiofromlinux") Stay tuned!